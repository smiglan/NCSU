# -*- coding: utf-8 -*-
"""763P1datafinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MQCL9LcJyRoa6Hk75ZAuGR89h5HZYtCG
"""

##Convert elliptical coordinates to rectangular
from google.colab import drive
drive.mount('/content/gdrive', force_remount=True)
path = '/content/gdrive/My Drive/ECE763/'
from PIL import Image
import glob
import cv2
import numpy as np
import matplotlib.pyplot as plt


import sys, os
import numpy as np
from math import *
from PIL import Image

def filterCoordinate(c,m):
  if c < 0:
    return 0
  elif c > m:
    return m
  else:
    return c

ellipse_filename = path+'FDDB-folds/annotFile.txt'
rect_filename = path+'FDDB-folds/FDDB-fold-10-rectList.txt'

with open(ellipse_filename) as f:
  lines = [line.rstrip('\n') for line in f]
f = open(rect_filename,'w')

i = 0
while i < len(lines):

    img_file = path+lines[i]+ '.jpg'
    img = Image.open(img_file)

    w = img.size[0]
    h = img.size[1]
    num_faces = int(lines[i+1])
    if num_faces == 1:
      for j in range(num_faces):
        ellipse = lines[i+2+j].split()[0:5]
        a = float(ellipse[0])
        b = float(ellipse[1])
        angle = float(ellipse[2])
        centre_x = float(ellipse[3])
        centre_y = float(ellipse[4])

        tan_t = -(b/a)*tan(angle)
        t = atan(tan_t)
        x1 = centre_x + (a*cos(t)*cos(angle) - b*sin(t)*sin(angle))
        x2 = centre_x + (a*cos(t+pi)*cos(angle) - b*sin(t+pi)*sin(angle))
        x_max = filterCoordinate(max(x1,x2),w)
        x_min = filterCoordinate(min(x1,x2),w)

        if tan(angle) != 0:
          tan_t = (b/a)*(1/tan(angle))
        else:
          tan_t = (b/a)*(1/(tan(angle)+0.0001))
        t = atan(tan_t)
        y1 = centre_y + (b*sin(t)*cos(angle) + a*cos(t)*sin(angle))
        y2 = centre_y + (b*sin(t+pi)*cos(angle) + a*cos(t+pi)*sin(angle))
        y_max = filterCoordinate(max(y1,y2),h)
        y_min = filterCoordinate(min(y1,y2),h)

        text = img_file + ',' + str(x_min) + ',' + str(y_min) + ',' + str(x_max) + ',' + str(y_max)	+ '\n'
        print(i,text)
        f.write(text)

    i = i + num_faces + 2


f.close()

with open(rect_filename) as f:
  lines = [line.rstrip('\n') for line in f]
print(len(lines))

import math
facepath = path+'MyData1/Face/'
nonfacepath = path+'MyData1/NonFace/'

back = []
for i,v in enumerate(lines):
  v = v.split(',')
  img = cv2.imread(v[0])
  x_min,y_min,x_max,y_max = v[1],v[2],v[3],v[4]
  crop_image = img[math.floor(float(y_min)):math.floor(float(y_max)), math.floor(float(x_min)):math.floor(float(x_max))]

  height, width = crop_image.shape[:2]
  if img.shape[0]- math.floor(float(y_max)) >60 and img.shape[1]-math.floor(float(x_max)) >60:
    ry = np.random.randint(0,img.shape[0]- math.floor(float(y_max))-60)
    rx = np.random.randint(0,img.shape[1]- math.floor(float(x_max))-60)
    back.append(img[math.floor(float(y_max))+ry:math.floor(float(y_max))+ry+60,math.floor(float(x_max))+rx:math.floor(float(x_max))+rx+60])
    cv2.imwrite(facepath+'Face_'+str(i)+'.jpg', crop_image)
    cv2.imwrite(nonfacepath+'Non_Face_'+str(i)+'.jpg', img[math.floor(float(y_max))+ry:math.floor(float(y_max))+ry+60,math.floor(float(x_max))+rx:math.floor(float(x_max))+rx+60])
    continue
  elif math.floor(float(y_min)) >60 and math.floor(float(x_min)) >60:
    ry = np.random.randint(0,math.floor(float(y_min))-60)
    rx = np.random.randint(0,math.floor(float(x_min))-60)
    back.append(img[ry:ry+60,rx:rx+60])
    cv2.imwrite(facepath+'Face_'+str(i)+'.jpg', crop_image)
    cv2.imwrite(nonfacepath+'Non_Face_'+str(i)+'.jpg',img[ry:ry+60,rx:rx+60])
    continue
    # if back.shape != (60, 60, 3):
    #   print('2wrongbitch',back.shape)
  else:
    print('no patch available')

image_face = []
dim = (20,20)
for filename in glob.glob(path+'MyData1/Face/*.jpg'): #assuming gif
    im=cv2.imread(filename)
    im = cv2.resize(im, dim,interpolation = cv2.INTER_CUBIC)
    image_face.append(im)
    cv2.imwrite(path+'MyData2/Face/'+'Face_'+str(len(image_face))+'.jpg', im)
    print(len(image_face))

image_nonface = []
for filename in glob.glob(path+'MyData1/NonFace/*.jpg'): 
    im=cv2.imread(filename)
    im = cv2.resize(im, dim)
    image_nonface.append(im)
    cv2.imwrite(path+'MyData2/NonFace/'+'Face_'+str(len(image_nonface))+'.jpg', im)
    print(len(image_nonface))

image_face = np.array([image_face])
image_face = np.reshape(image_face,(1358,1200))
np.save(path+'MyData2/FaceData',image_face)

image_nonface = np.array([image_nonface])
image_nonface = np.reshape(image_nonface,(1358,1200))
np.save(path+'MyData2/NonFaceData',image_nonface)

np.save(path+'MyData4/ftrain',image_face[0:1000])
np.save(path+'MyData4/nftrain',image_nonface[0:1000])
np.save(path+'MyData4/ftest',image_face[1200:1300])
np.save(path+'MyData4/nftest',image_nonface[1200:1300])